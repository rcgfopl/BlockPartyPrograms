#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     IR,             sensorHiTechnicIRSeeker600)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDispenser,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     mIntake,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mFlag,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     mLift,         tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define max 100
#define min 0
/*------------------------------------------------|
|Motor A1 is Right; Motor A2 is mDispenser.				|
|Motor C1 is Left; Motor C2 is mLift.							|
|Motor B1 is mIntake;   Motor B2 is mFlag.				|
|Motors run on a scale of -100(max backwards) to  |
|100 (max forwards), with no power being 0.				|
|Servos run on a scale of 0 (max backwards) to 		|
|256(max forwards), with 127 being no power.			|
|------------------------------------------------*/

void drive() //moving method
{
	if(abs(joystick.joy1_y1)>10) //prevents idle movement from small values
	{
		motor[Left] = -(joystick.joy1_y1*100)/128; //moves left side forward/backward on the motor's scale
	}
	else
	{
		motor[Left] = 0; //stops movement of the left side
	}

	if(abs(joystick.joy1_y2)>10)
	{
		motor[Right] = -(joystick.joy1_y2*100)/128; //moves right side forward/backward on the motor's scale
	}
	else
	{
			motor[Right] = 0; //stops movement of the right side
	}
}

void intake() //intake method
{
	if(joy1Btn(5))
		motor[mIntake] = 100; //brings blocks in
	else if(joy1Btn(7))
		motor[mIntake] = -100; //pushes blocks out
	else
		motor[mIntake] = 0; //stops moving intake attachment
}

void flag() //flag method
{
	if(joy1Btn(1))
		motor[mFlag]= 100; //moves flag attachment clockwise
	else if(joy1Btn(3))
		motor[mFlag]= -100; //moves flag attachment counterclockwise
	else
		motor[mFlag] = 0; //stops moving flag attachment
}

void lift() //lift method
{
	if(joy1Btn(6))
	{
		motor[mLift] = 100; //moves lift up
	}
	else if(joy1Btn(8))
	{
		motor[mLift] = -100; //moves lift down
	}
	else
	{
		motor[mLift] = 0; //stops lift
	}
}

void dispenser()//dispenser method
{
	if(joy1Btn(2))
	{
		motor[mDispenser] = 100; //pushes dispenser forward and dispenses blocks
	}
	else if(joy1Btn(4))
	{
		motor[mDispenser] = -100; //brings dispenser back
	}
	else
	{
		motor[mDispenser] = 0; //dispenser stops moving
	}
}

task main()
{
	waitForStart();
	while(true)
	{
		getJoystickSettings(joystick);  // Update Buttons and Joysticks
		drive();
		intake();
		flag();
		lift();
		dispenser();
		//all of the above code runs the methods that control all the motorized parts of our robot.
    wait1Msec(10); //a wait to ensure that multiple signals do not stack and to prevent lag.
	}
}
